# Pintos-----------## `pintos` OS를 분석하고 코드를 개선시키는 프로젝트를 진행한다.---------------수행환경* pintos설치*  bochs -2.6.2 사용* utils/squish-pty.c compile -->```bash   $ cd src/utils/ , gcc -Wall -w -o squish-pty squish-pty.c ```  ```bash$ cd src/thread --> make$ cd build  --> make check```* make check 사용해서 test --------------###  Alarm 개선1 .개요 * 현재의 timer_sleep()함수는 busy-wating방식을 사용한다. timer_sleep()의 수행방식을 sleep -wake 방식으로 개선해 나가기로 한다.* 지금 코드는 정해진 시간이 경과할 때까지 while문을 돌면서 thread_yield()를 반복 호출하고 있다.이로 인해 많은 시스템자원을 낭비하고 있다.-------------------------2 . 개선아이디어* time_sleep()가 호출 시 스레드를 block상태로 변경하고 그 시간을 기록후에 ticks를 더한 시각이 경과하면 unblock상태로 변경하여 ready queue로  이동시킨다.* TCB에 언제 상태를 unblock시켜야 하는지 기록할 변수를 wakeup으로 설정한다.  ----------------------------------------------------* modified thread.h* modeified thread_init* modeified timer_sleep* add thread_sleep* add thread_wake* add thread_less_sort* modeified timer_interrupt```bash$ make check `````` bashpass tests/threads/alarm-singlepass tests/threads/alarm-multiplepass tests/threads/alarm-simultaneouspass tests/threads/alarm-prioritypass tests/threads/alarm-zeropass tests/threads/alarm-negative```--------### preemptive dynamic priority Scheduling1. 개요 * 현재 pintos에는 라운드로빈 스케줄러가 구현되어 있다. 이를 수정하여 스레드 별우선순위에 따라 스케줄링 할 수 있는 우선순위 스케줄러를 새로 구현한다. 특히, preemptivedynamic priority scheduling을 구현한다* 우선순위 스케줄링 방식의 문제점은 우선순위 역전 현상이 일어날 수 있다는 것이다. 이를 방지할 수 있도록 우선순위 스케줄러에 priority inheritance(donation) 기능을 구현한다.* condition variable 에 대한 signal연산을 통해 동기화와  preemptive scheduling 해결한다.------------------------------2 . 개선아이디어 *  현재 RoundRobin 스케줄링 방식으로 되어있기 때문에 타이머 인터럽트 발생시마다 thread가 ready-queue에 맨 마지막에 매달린다.그리고 thread_unblock함수가 호출 될 때 와 최초 스레드 생성시에도 ready-queue맨끝에 매달린다 만약 뒤에 있는 thread를 급하게 처리해야 할 시 효율성이 떨어지게 된다. 또한 먼저 작업을 요하는 thread가 존재하는 경우 대기 시간도 길어지게 된다. 따라서 우선순위에 따라서 thread가 스케줄링되는 방식으로 개선하려고 한다. * semaphore 에 대한 우선 순위 정렬을 하여 semaphore에 waiters리스트에서 가장 높은 우선순위의 thread를 schedule한다.  * priority inversion 현상을 해결하기 위해서 lock을 대상으로 개선시킨다. Lock은 기본적으로 하나의 thread만을 허용한다. 따라서 이런 lock을 이용한다면 동기화 문제가 발생되게 된다. 또한 priority가 높은 thread가 실행을 위해 필요로 하는 lock을 priority가 낮은 thread가 이미 가지고 있다면 낮은 priority의 thread는 lock 을 release하기 위해서 실행될 수가 없다. 이러한 priority inversion을 해결하기 위해서 priority donate를 사용한다. 높은 priority를 가진 thread가 잠시 낮은 priority를 가진 thread에게 자신의 priority를 donation하면서 낮은 priority를 가진 thread가 실행되고 lock을 release하고 다시 자기 자신의 priority로 돌아간 후 높은 priority의 thread가 마저 실행된다. 이러한 방법을 구현해낸다.   * cond_signal을 개선하여 signal 연산이 있을 때마다 우선순위를 스케줄링 해준다. ------------------------------add `thread_compare_priority()`add `thread_update_pri()`add `thread_get_lock()`add `lock_compare_priority()`add `cond_compare_priority()`modified `thread.h`modified `synch.h`modified `thread_create`modified `thread_unblock`modified `thread_set_priority`modified ` thread_yield`modified `sema_down`modified `sema_up`modified ` lock_acquire`modified `thread_update_pri`modified `lock_release`modifed `cond_signal````bash$ make check`````` bashpass tests/threads/alarm-singlepass tests/threads/alarm-multiplepass tests/threads/alarm-simultaneouspass tests/threads/alarm-prioritypass tests/threads/alarm-zeropass tests/threads/alarm-negativepass tests/threads/priority-changepass tests/threads/priority-donate-onepass tests/threads/priority-donate-multiplepass tests/threads/priority-donate-multiple2pass tests/threads/priority-donate-nestpass tests/threads/priority-donate-semapass tests/threads/priority-donate-lowerpass tests/threads/priority-fifopass tests/threads/priority-preemptpass tests/threads/priority-semapass tests/threads/priority-condvarpass tests/threads/priority-donate-chain```